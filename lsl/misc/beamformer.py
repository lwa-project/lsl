# -*- coding: utf-8 -*-

"""
Module to allow for post-acquisition delay-and-sum beamforming with TBW 
and TBN data using both integer sample delays for time series data 
(intDelayAndSum) and fractional delays for time series data transformed to 
the frequency domain (fftDelayAndSum).  fftDelayAndSum is still under 
development.
"""

import os
import sys
import aipy
import math
import numpy

from lsl.common.paths import data as dataPath
from lsl.common.constants import c
from lsl.common import dp as dp_common
from lsl.correlator import uvUtils

__version__ = '0.2'
__revision__ = '$Rev$'
__all__ = ['BeamformingError', 'calcDelay', 'intDelayAndSum', 'intBeamShape', 'fftDelayAndSum', 'fftBeamShape', '__version__', '__revision__', '__all__']

class BeamformingError(Exception):
	"""
	Base class for all exceptions in this file.
	"""

	def __init__(self, strerror, errno='-1'):
		self.errno = errno
		self.strerror = strerror
		self.filename = None
		self.args = (errno, strerror)

	def __str__(self):
		return "%s" % self.strerror


def __loadStandResponse(freq=49.0e6):
	"""
	Create an aipy.amp.beam object that holds the reponse for a single 
	isolated stand.  The stand response is based on NEC4 models at a variety
	of frequencies within the LWA frequency range.
	"""

	# Read in the spherical harmonic representation of the beam distributed with
	# LSL
	dd = numpy.load(os.path.join(dataPath, 'beam-shape.npz'))
	coeffs = dd['coeffs']

	# Calculate how many harmonics are stored in the data set and reorder the data
	# to aipy's liking
	deg = coeffs.shape[0]-1
	lmax = int((math.sqrt(1+8*coeffs.shape[1])-3)/2)
	beamShapeDict = {}
	for i in range(deg+1):
		beamShapeDict[i] = numpy.squeeze(coeffs[-1-i,:])

	# Build the beam object and done
	return aipy.amp.BeamAlm(numpy.array([freq/1e9]), lmax=lmax, mmax=lmax, deg=deg, nside=128, coeffs=beamShapeDict)


def calcDelay(antennas, freq=49.0e6, azimuth=0.0, elevation=90.0):
	"""
	Calculate the time delays for delay-and-sum beam forming a collection of 
	stands looking in at a particular azimuth and elevation (both in degrees).  
	A numpy array of the geometric + cable delays in seconds is returned.
	"""

	# Make sure the pointing coordinates make sense
	if elevation < 0 or elevation > 90:
		raise BeamformingError("Pointing elevation (%.2f deg) is out of range [0, 90]" % elevation)
	if azimuth < 0 or azimuth > 360:
		raise BeamformingError("Pointing azimuth (%.2f deg) is out of range [0, 360]" % azimuth)

	# Get the positions of the stands and compute the mean center of the array
	xyz = numpy.zeros((len(antennas),3))
	i = 0
	for ant in antennas:
		xyz[i,0] = ant.stand.x
		xyz[i,1] = ant.stand.y
		xyz[i,2] = ant.stand.z
		i += 1

	arrayX = xyz[:,0].mean()
	arrayY = xyz[:,1].mean()
	arrayZ = xyz[:,2].mean()

	# Build up a unit vector that points in the direction azimuth,elevation
	rAz = azimuth*numpy.pi/180.0
	rEl = elevation*numpy.pi/180.0
	source = numpy.array([numpy.cos(rEl)*numpy.sin(rAz), 
						numpy.cos(rEl)*numpy.cos(rAz), 
						numpy.sin(rEl)])

	# Compute the stand positions relative to the average and loop over stands
	# to compute the time delays in seconds
	arrayXYZ = xyz - numpy.array([arrayX, arrayY, arrayZ])
	delays = numpy.zeros((len(antennas),))
	for i in list(range(len(antennas))):
		delays[i] = numpy.dot(source, arrayXYZ[i,:]) / c

	# Get the cable delays for each stand and add that in as well
	for i in list(range(len(antennas))):
		delays[i] = antennas[i].cable.delay(freq) - delays[i]

	# Done
	return delays


def intDelayAndSum(antennas, data, sampleRate=dp_common.fS, azimuth=0.0, elevation=90.0):
	"""
	Given a list of antennas and a 2-D data stream with stands enumerated
	along the first axis and time series samples along the second axis, 
	delay and sum the data stream into one beam.  The delays applied are 
	integer sample delays.  Return a 1-D numpy array of the time series data 
	associated with the formed beam.

	.. note:
		In order for this output to be properly processed by :func:`lsl.correlate.fx.calcSpectra`,
		The data need to be convert to a 2-D array via::

			>>> beamData = intDelayAndSum(stands, data)
			>>> beamData.shape = (1,)+beamData.shape

	.. versionchanged:: 0.4.0
		Switched over to passing in Antenna instances generated by the
		:mod:`lsl.common.stations` module instead of a list of stand ID
		numbers.
	"""

	# Get the stand delays and convert the delay times from seconds to samples
	delays = calcDelay(antennas, azimuth=azimuth, elevation=elevation)
	delays = numpy.round(delays*sampleRate).astype(numpy.int16)

	# Figure out the polarizations
	pols = numpy.array([ant.pol for ant in antennas])
	pol0 = numpy.where( pols == 0 )[0]
	pol1 = numpy.where( pols == 1 )[0]

	# Make the delays into something meaningful for the shifting of the data 
	# streams
	delays = delays.max() - delays

	# Delay and sum by looping over stands inside of looping over times
	output = numpy.zeros((2, (data.shape[1]-delays.max())), dtype=data.dtype)
	for s,p in zip(range(len(antennas)), pols):
		start = delays[s]
		stop = data.shape[1] - delays.max() + start
		output[p,:] += data[s,start:stop]

	# Check for empty polarization data.  Always return a 2-D array for the data
	if len(pol0) == 0:
		output = output[1,:]
		output.shape = (1,) + output.shape
	elif len(pol1) == 0:
		output = output[0,:]
		output.shape = (1,) + output.shape
	else:
		pass

	# Done
	return output


def __intBeepAndSweep(antennas, arrayXYZ, t, freq, azimuth, elevation, beamShape=1.0, sampleRate=dp_common.fS, direction=(0.0, 90.0)):
	"""
	Worker function for intBeamShape that 'beep's (makes a simulated signals) and
	'sweep's (delays it appropriately).
	"""

	# Convert from degrees to radian
	rAz = azimuth*numpy.pi/180.0
	rEl = elevation*numpy.pi/180.0

	# Unit vector for the currect on-sky location
	currPos = numpy.array([numpy.cos(rEl)*numpy.sin(rAz), 
						numpy.cos(rEl)*numpy.cos(rAz), 
						numpy.sin(rEl)])
	# Stand response in this direction
	currResponse = beamShape

	# Loop over stands to build the simulated singnals
	signals = numpy.zeros((len(antennas), len(t)))
	for i in list(range(len(antennas))):
		currDelay = antennas[i].cable.delay(freq) - numpy.dot(currPos, arrayXYZ[i,:]) / c
		signals[i,:] = currResponse * numpy.cos(2*numpy.pi*freq*(t + currDelay))

	# Beamform with delay-and-sum and store the RMS result
	beamHere = intDelayAndSum(antennas, signals, sampleRate=sampleRate, azimuth=direction[0], elevation=direction[1])
	
	# Reduce the array dimensions
	beamHere = beamHere[0,:]

	# Return
	sigHere = numpy.sqrt((beamHere**2).mean())
	return sigHere


def intBeamShape(antennas, sampleRate=dp_common.fS, azimuth=0.0, elevation=90.0, progress=False, DisablePool=False):
	"""
	Given a list of antennas, compute the on-sky response of the delay-and-sum
	scheme implemented in intDelayAndSum.  A 360x90 numpy array spaning azimuth
	and elevation is returned.
	
	.. versionchanged:: 0.4.0
		Switched over to passing in Antenna instances generated by the
		:mod:`lsl.common.stations` module instead of a list of stand ID
		numbers.
		
	.. versionchanged:: 0.4.2
		Allowed for multiple polarization data to be delayed-and-sumed correctly 
		and insured that a 2-D array is always returned (pol(s) by samples)
	"""

	# Set the frequency
	freq = 49.0e6

	# Get the stand delays and convert the delay times from seconds to samples
	delays = calcDelay(antennas, freq=freq, azimuth=azimuth, elevation=elevation)
	delays = numpy.round(delays*sampleRate).astype(numpy.int16)

	# Build up a base time array, load in the cable delays, and get the stand 
	# positions for geometric delay calculations.
	t = numpy.arange(0,1000)/sampleRate
	xyz = numpy.zeros((len(antennas),3))
	i = 0
	for ant in antennas:
		xyz[i,0] = ant.stand.x
		xyz[i,1] = ant.stand.y
		xyz[i,2] = ant.stand.z
		i += 1

	arrayX = xyz[:,0].mean()
	arrayY = xyz[:,1].mean()
	arrayZ = xyz[:,2].mean()
	arrayXYZ = xyz - numpy.array([arrayX, arrayY, arrayZ])

	# Load in the respoonse of a single isolated stand
	standBeam = __loadStandResponse(freq)

	# The multiprocessing module allows for the creation of worker pools to help speed
	# things along.  If the processing module is found, use it.  Otherwise, set
	# the 'usePool' variable to false and run single threaded.
	try:
		from multiprocessing import Pool, cpu_count
		
		# To get results pack from the pool, you need to keep up with the workers.  
		# In addition, we need to keep up with which workers goes with which 
		# baseline since the workers are called asychronisly.  Thus, we need a 
		# taskList array to hold tuples of baseline ('count') and workers.
		taskPool = Pool(processes=int(numpy.ceil(cpu_count()*0.70)))
		taskList = []

		usePool = True
		progress = False
	except ImportError:
		usePool = False

	# Turn off the thread pool if we are explicitly told not to use it.
	if DisablePool:
		usePool = False

	# Build up the beam shape over all azimuths and elevations
	beamShape =  numpy.zeros((360,90))
	for az in list(range(360)):
		rAz = az*numpy.pi/180.0
		for el in list(range(90)):
			rEl = el*numpy.pi/180.0
			beamShape[az,el] = standBeam.response(aipy.coord.azalt2top(numpy.concatenate([[rAz], [rEl]])))[0][0]

	# Build the output array and loop over all azimuths and elevations
	output = numpy.zeros((360,90))
	for az in list(range(360)):
		rAz = az*numpy.pi/180.0
		for el in list(range(90)):
			rEl = el*numpy.pi/180.0

			# Display the progress meter if the `progress' keyword is set to True.  The
			# progress meter displays a `.' every 2% complete and the percentages every
			# 10%.  At 100%, `Done' is displayed.
			if progress:
				fracDone = (az*90+el) / 32400.0 * 100
				if fracDone % 10 == 0 and round(fracDone,2) != 100:
					sys.stdout.write("%i%%" % fracDone)
				elif round(fracDone,2) == 100:
					sys.stdout.write("Done\n")
				elif round(fracDone,3) % 2 == 0:
					sys.stdout.write(".")
				else:
					pass
				sys.stdout.flush()

			if usePool:
				task = taskPool.apply_async(__intBeepAndSweep, args=(antennas, arrayXYZ, t, freq, az, el), kwds={'beamShape': beamShape[az,el], 'sampleRate': sampleRate, 'direction': (azimuth, elevation)})
				taskList.append((az,el,task))
			else:
				# Unit vector for the currect on-sky location
				currPos = numpy.array([numpy.cos(rEl)*numpy.sin(rAz), 
								numpy.cos(rEl)*numpy.cos(rAz), 
								numpy.sin(rEl)])
				# Stand response in this direction
				currResponse = standBeam.response(aipy.coord.azalt2top(numpy.concatenate([[rAz], [rEl]])))[0][0]

				# Loop over stands to build the simulated singnals
				signals = numpy.zeros((len(antennas), 1000))
				for i in list(range(len(antennas))):
					currDelay = antennas[i].cable.delay(freq) - numpy.dot(currPos, arrayXYZ[i,:]) / c
					signals[i,:] = currResponse * numpy.cos(2*numpy.pi*freq*(t + currDelay))

				# Beamform with delay-and-sum and store the RMS result
				beam = intDelayAndSum(antennas, signals, sampleRate=sampleRate, azimuth=azimuth, elevation=elevation)
				output[az,el] = numpy.sqrt((beam**2).mean())

	# If pooling... Close the pool so that it knows that no ones else is joining.
	# Then, join the workers together and wait on the last one to finish before
	# saving the results.
	if usePool:
		taskPool.close()
		taskPool.join()

		# This is where he taskList list comes in handy.  We now know who did what
		# when we unpack the various results
		for az,el,task in taskList:
			output[az,el] = task.get()

		# Destroy the taskPool
		del(taskPool)

	# Done
	return output


def fftDelayAndSum(antennas, data, sampleRate=dp_common.fS, LFFT=256, CentralFreq=49.0e6, azimuth=0.0, elevation=90.0):
	"""
	Given a list of antennas and a data stream of the form stands x times, 
	delay and sum the data stream into one beam.  The delays first applied 
	as integer sample delays.  Then, the data are transformed to the 
	frequency domain and the remainder of the delay is applied as a phase 
	rotation.  A tuple consisting of the frequency array and a numpy array 
	of the frequency-domain data over time is returned.
	
	.. versionchanged:: 0.4.0
		Switched over to passing in Antenna instances generated by the
		:mod:`lsl.common.stations` module instead of a list of stand ID
		numbers.
		
	.. versionchanged:: 0.4.2
		Allowed for multiple polarization data to be delayed-and-sumed correctly 
		and insured that a 3-D array is always returned (pol(s) by channels by time)
	"""

	# Get the stand delays in seconds
	delays = calcDelay(antennas, azimuth=azimuth, elevation=elevation)

	# Make the delays into something meaningful for the shifting of the data 
	# streams.  Then, get the integer delay and sub-sample delay for each stand
	delays = delays.max() - delays
	intDelays = numpy.round(delays*sampleRate).astype(numpy.int16)
	frcDelays = delays - intDelays/sampleRate
	
	# Figure out the polarizations
	pols = numpy.array([ant.pol for ant in antennas])
	pol0 = numpy.where( pols == 0 )[0]
	pol1 = numpy.where( pols == 1 )[0]

	# Compute the frequencies of the FFT
	freq = numpy.fft.fftfreq(LFFT, d=1.0/sampleRate)
	if data.dtype.kind == 'c':
		freq = freq + CentralFreq
		freq = numpy.fft.fftshift(freq)

	# Loop over stands and FFT sections to compute the formed beam
	output = numpy.zeros((2, LFFT, (data.shape[1]-intDelays.max())/LFFT), dtype=numpy.complex64)
	for s,p in zip(range(len(antennas)), pols):
		for l in range(output.shape[2]):
			section = data[s,(l*LFFT+intDelays[s]):((l+1)*LFFT+intDelays[s])]
			sectionF = numpy.fft.fft(section)
			if data.dtype.kind == 'c':
				sectionF = numpy.fft.fftshift(sectionF)
			sectionF *= numpy.exp(2j*numpy.pi*freq*frcDelays[s])
			output[p,:,l] += sectionF

	# Check for empty polarization data.  Always return a 3-D array for the data
	if len(pol0) == 0:
		output = output[1,:,:]
		output.shape = (1,) + output.shape
	elif len(pol1) == 0:
		output = output[0,:,:]
		output.shape = (1,) + output.shape
	else:
		pass

	# Done
	return (freq, output)


def fftBeamShape(antennas, sampleRate=dp_common.fS, LFFT=256, CentralFreq=49.0e6, azimuth=0.0, elevation=90.0, progress=False):
	"""
	Given a list of antennas, compute the on-sky response of the delay-and-sum
	scheme implemented in intDelayAndSum.  A 360x90 numpy array spaning azimuth
	and elevation is returned.
	
	.. versionchanged:: 0.4.0
		Switched over to passing in Antenna instances generated by the
		:mod:`lsl.common.stations` module instead of a list of stand ID
		numbers.
	"""

	# Get the stand delays and convert the delay times from seconds to samples
	delays = calcDelay(antennas, freq=CentralFreq, azimuth=azimuth, elevation=elevation)
	delays = numpy.round(delays*sampleRate).astype(numpy.int16)

	# Build up a base time array, load in the cable delays, and get the stand 
	# positions for geometric delay calculations.
	t = numpy.arange(0,1000)/sampleRate
	dlyCache = uvUtils.CableCache(CentralFreq, applyDispersion=True)
	xyz = uvUtils.getXYZ(stands)
	arrayX = xyz[:,0].mean()
	arrayY = xyz[:,1].mean()
	arrayZ = xyz[:,2].mean()
	arrayXYZ = xyz - numpy.array([arrayX, arrayY, arrayZ])

	# Load in the respoonse of a single isolated stand
	standBeam = __loadStandResponse(freq=CentralFreq)

	# Build the output array and loop over all azimuths and elevations
	output = numpy.zeros((360,90))
	for az in list(range(360)):
		rAz = az*numpy.pi/180.0
		for el in list(range(90)):
			rEl = el*numpy.pi/180.0

			# Display the progress meter if the `progress' keyword is set to True.  The
			# progress meter displays a `.' every 2% complete and the percentages every
			# 10%.  At 100%, `Done' is displayed.
			if progress:
				fracDone = (az*90+el) / 32400.0 * 100
				if fracDone % 10 == 0 and round(fracDone,2) != 100:
					sys.stdout.write("%i%%" % fracDone)
				elif round(fracDone,2) == 100:
					sys.stdout.write("Done\n")
				elif round(fracDone,3) % 2 == 0:
					sys.stdout.write(".")
				else:
					pass
				sys.stdout.flush()

			# Unit vector for the currect on-sky location
			currPos = numpy.array([numpy.cos(rEl)*numpy.sin(rAz), 
							numpy.cos(rEl)*numpy.cos(rAz), 
							numpy.sin(rEl)])
			# Stand response in this direction
			currResponse = standBeam.response(aipy.coord.azalt2top(numpy.concatenate([[rAz], [rEl]])))[0][0]

			# Loop over stands to build the simulated singnals
			signals = numpy.zeros((len(antennas), 1000))
			for i in list(range(len(antennas))):
				currDelay = antennas[i].cable.delay(CentralFreq) - numpy.dot(currPos, arrayXYZ[i,:]) / c
				signals[i,:] = currResponse * numpy.cos(2*numpy.pi*CentralFreq*(t + currDelay))

			# Beamform with delay-and-sum and store the RMS result
			freq, beam = fftDelayAndSum(antennas, signals, sampleRate=sampleRate, LFFT=LFFT, CentralFreq=CentralFreq, 
								azimuth=azimuth, elevation=elevation)
			output[az,el] = (numpy.abs(beam)**2).max()

	# Done
	return output
